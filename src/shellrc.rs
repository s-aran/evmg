pub mod shellrc {
    use std::fs::File;
    use std::io::Write;
    use std::path::Path;
    use std::rc::Rc;

    use crate::envvar;
    use crate::envvar::environment_variable::EnvironmentVariable;

    pub trait ShellRunCommandFile {
        fn new(shell: &str) -> Self;

        fn write(&self, filepath: &Path) -> Result<(), String> {
            let data: String = match self.build() {
                Ok(s) => s,
                Err(e) => return Err(e),
            };

            let mut file = match File::create(filepath) {
                Ok(f) => f,
                Err(e) => return Err(e.to_string()),
            };

            return match file.write(data.as_bytes()) {
                Ok(_) => Ok(()),
                Err(e) => Err(e.to_string()),
            };
        }

        fn build(&self) -> Result<String, String>;

        fn build_using_setenv(header: &String, list: &Vec<(String, String)>) -> String {
            let mut result: Vec<String> = Vec::new();
            if header.len() > 0 {
                result.push(header.to_string());
            }

            for (k, v) in list.iter() {
                result.push(format!("setenv {} {}", k, v));
            }

            result.join("\n")
        }

        fn build_using_export(header: &String, list: &Vec<(String, String)>) -> String {
            let mut result: Vec<String> = Vec::new();
            if header.len() > 0 {
                result.push(header.to_string());
            }

            for (k, v) in list.iter() {
                result.push(format!("export {}={}", k, v));
            }

            result.join("\n")
        }

        fn build_using_powershell(header: &String, list: &Vec<(String, String)>) -> String {
            let mut result: Vec<String> = Vec::new();
            if header.len() > 0 {
                result.push(header.to_string());
            }

            for (k, v) in list.iter() {
                result.push(format!("export {}={}", k, v));
            }

            result.join("\n")
        }

        fn build_comment(shell: &str) -> String {
            const NAME: Option<&str> = option_env!("CARGO_PKG_NAME");
            const VERSION: Option<&str> = option_env!("CARGO_PKG_VERSION");

            let mut result: Vec<String> = Vec::new();

            result.push("#".repeat(80));
            result.push("#".to_string());
            result.push(format!(
                r#"#   This file is a run control for {} generated by {} {}."#,
                shell,
                NAME.unwrap_or("???"),
                VERSION.unwrap_or("???"),
            ));
            result.push(r#"#   Do not edit this file manually."#.to_string());
            result.push("#".to_string());
            result.push("#".repeat(80));

            result.join("\n")
        }
    }

    pub struct ShellRunCommandFileData {
        shell: String,
        vars: Vec<(String, String)>,
    }

    impl ShellRunCommandFileData {
        pub fn get(&self, key: &String) -> Result<String, String> {
            for (k, v) in self.vars.iter() {
                if k == key {
                    return Ok(v.to_string());
                }
            }

            Err(format!("key not found: {}", key))
        }

        pub fn set(&mut self, key: &String, value: &String) {
            for (i, (k, _)) in self.vars.iter().enumerate() {
                if k == key {
                    (&mut self.vars)[i] = (key.to_string(), value.to_string());
                    return;
                }
            }
        }

        pub fn add(&mut self, key: &String, value: &String) {
            for (k, _) in self.vars.iter() {
                if k == key {
                    self.set(key, value);
                    return;
                }
            }

            self.vars.push((key.to_string(), value.to_string()));
        }

        pub fn delete(&mut self, key: &String) -> Result<(), String> {
            for (i, (k, _)) in self.vars.iter().enumerate() {
                if k == key {
                    self.vars.remove(i);
                    return Ok(());
                }
            }

            Err(format!("key not found: {}", key))
        }
    }

    impl ShellRunCommandFile for ShellRunCommandFileData {
        fn new(shell: &str) -> Self {
            Self {
                shell: shell.to_string(),
                vars: Vec::new(),
            }
        }

        fn build(&self) -> Result<String, String> {
            let result = match &*self.shell.to_lowercase() {
                "bash" | "zsh" | "fish" | "dash" => {
                    let shell = self.shell.to_lowercase();
                    let comment = Self::build_comment(&shell);
                    Self::build_using_export(&comment, &self.vars)
                }
                "csh" => {
                    let shell = self.shell.to_lowercase();
                    let comment = Self::build_comment(&shell);

                    Self::build_using_setenv(&comment, &self.vars)
                }
                "powershell" | "ps" | "ps1" => {
                    let shell = "powershell".to_string();
                    let comment = Self::build_comment(&shell);

                    Self::build_using_powershell(&comment, &self.vars)
                }
                _ => return Err(format!("unknown shell name: {}", self.shell)),
            };

            Ok(result)
        }
    }
}
